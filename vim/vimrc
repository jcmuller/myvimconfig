" Juan C. Muller's .vimrc
" {{{ Basics
" Turn off compatibility with VI.
set nocompatible
" }}}
" {{{ Plugins
" {{{ Setup
" Use vim-plug to easily modify the runtime path to include all
" plugins under the ~/.vim/plugged directory
if empty(glob('~/.vim/autoload/plug.vim'))
	silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
				\ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
	autocmd VimEnter * PlugInstall | source ~/.vim/vimrc
endif
" }}}
" {{{ Plugins
source ~/.vim/include/plug.vim
" }}}
" }}}
" {{{ Indent and spacing
" All nice indent options
set autoindent
set cindent
set cinkeys-=0# " don't force # indentation
set copyindent	"copy the previous indentation on autoindenting
set expandtab
"set noexpandtab
set shiftround "Round indent to multiple of 'shiftwidth'
set shiftwidth=2 "Number of spaces to use for each step of (auto)indent
set smartindent
set smarttab "use shiftwidth
set softtabstop=2 "Number of spaces that a <Tab> counts for while editing
set tabstop=2 "Number of spaces that a <Tab> in the file counts for
" }}}
" {{{ Search
set hlsearch "highlight search term
set incsearch "search as you type
set nowrapscan "Only search forward in buffer.

"if executable('rg')
set grepprg=rg\ --vimgrep\ --no-heading
set grepformat=%f:%l:%c:%m
"endif
" }}}
" {{{ Global settings
" set autoread     "refresh file automatically if changed
set background=light
"set background=dark
set backup "do create backup files
set backspace=indent,eol,start "allow backspace to work across inserts and newlines.
set backupdir=~/.vim/backups
set bufhidden=unload
"set cmdheight=2 "Number of screen lines to use for the command line
set encoding=utf-8
set termencoding=utf-8
set fileformats=unix,dos,mac
set history=1000
"set iskeyword+=_,$,@,%,#                        "not word dividers
set laststatus=2 "don't combine status line with command line
set mouse=a "n "a all modes, n normal mode, v visual mode
set noautowrite "Don't write the contents of the file, if it has been modified, on each
set nolinebreak "don't break line after n characters (usually 70 unless otherwise spec'd)
set noshowmode
set number "show line numbers
set splitbelow "open help, et al, horizontally below, rather than vertically to the right
set splitright
set switchbuf=useopen,usetab "control behavior when switching buffers.
set tagbsearch "Binary tag search
"set term=xterm
set textwidth=95
set colorcolumn=80,95,120
set wrapmargin=0
set diffopt=context:3,iwhite,filler "diff options
" }}}
" {{{ Mapleader
let mapleader = ","
" }}}
" {{{ Match
set matchpairs+=<:>
set showmatch "highlight matching parenthesis, brace, bracket, etc.
set titlestring=%t\ (%f)
set title " Set window title
" }}}
" {{{ Syntax
" Check for version
if v:version >= 600
	syntax enable
	filetype on
	filetype indent on
	filetype plugin on
	filetype plugin indent on
endif
" "}}}
" {{{ List and tabline
if v:version >= 700
	set list
	set listchars=tab:\|\-,trail:•,extends:>,precedes:<,nbsp:@
	set showtabline=2 "always show tab line.
endif
" }}}
" {{{ GPG
if v:version >= 700
	let g:GPGPreferArmor = 1
	let g:GPGPreferSigned = 1
	let g:GPGDefaultRecipients = [$USER]
endif
" }}}
" {{{ Persistent undo
if has('persistent_undo')
	set undofile
	set undodir=~/.vim/var/undo
endif
" }}}
" {{{ Spell
if has('spell')
	set spell spelllang=en_us "spell checking enabled

	autocmd FileType gitconfig set nospell
	autocmd FileType man set nospell
	autocmd FileType netrw set nospell
	" autocmd FileType taglist set nospell
	autocmd FileType crontab set nospell
	autocmd FileType gitcommit set nolist
endif
" }}}
" {{{ Scroll
" Minimal number of screen lines to keep above and below the cursor.
set scrolloff=2

set sidescrolloff=5
set sidescroll=15
" }}}
" {{{ Hidden
" One of the most important options to activate. Allows you to switch from an
" unsaved buffer without saving it first. Also allows you to keep an undo
" history for multiple files. Vim will complain if you try to quit without
" saving, and swap files will keep you safe if your computer crashes.
set hidden
" }}}
" {{{ Wildmenu
" Better command-line completion
set wildmenu
set wildignore=*.swp,*.bak,*~,*.pyc,*.class,.git/,build/**
" }}}
" {{{ Showcmd
" Show partial commands in the last line of the screen
set showcmd
" }}}
" {{{ Windows
set equalalways
" }}}
" {{{ Case in search
" Use case insensitive search, except when using capital letters
set ignorecase
set smartcase
" }}}
" {{{ Confirm
" Instead of failing a command because of unsaved changes, instead raise a
" dialogue asking if you wish to save changed files.
set confirm
" }}}
" {{{ Visual bell
" Use visual bell instead of beeping when doing something wrong
set visualbell

" And reset the terminal code for the visual bell.  If visualbell is set, and
" this line is also included, vim will neither flash nor beep.  If visualbell
" is unset, this does nothing.
set t_vb=
" }}}
" {{{ Time outs
" Quickly time out on keycodes, but never time out on mappings
set notimeout ttimeout ttimeoutlen=200
" }}}
" {{{ Man pages
source $VIMRUNTIME/ftplugin/man.vim
" }}}
" {{{ NeoVim vs Vim
if has('nvim')
	source ~/.vim/include/nvim.vim
else
	source ~/.vim/include/vim.vim
endif
" }}}
" {{{ autocmds
"autocmd BufDelete,BufWritePost .vimrc source ~/.vimrc
"autocmd BufDelete .vimrc source ~/.vimrc
augroup arduino " {{{
	autocmd!
	autocmd BufRead,BufNewFile *.ino setlocal ft=arduino
	autocmd BufRead,BufNewFile *.pde setlocal ft=arduino
augroup END "}}}
augroup tmux " {{{
	autocmd!
	autocmd BufRead,BufNewFile *.tmux setlocal ft=tmux
augroup END" }}}
autocmd BufRead,BufWinEnter *.hbs set ft=handlebars
autocmd BufRead,BufWinEnter *.jelly setlocal ft=xml
augroup markdown " {{{
	autocmd!
	autocmd BufRead,BufWinEnter Glossary.md setlocal foldmethod=expr foldexpr=getline(v:lnum)=~'^#'?'>1':0&&getline(v:lnum+1)=~'^#'?'<1':1
	autocmd BufRead,BufNewFile *.md setlocal filetype=markdown
	autocmd FileType markdown setlocal formatoptions+=w tw=72
augroup END" }}}
augroup latex " {{{
	autocmd!
	autocmd BufRead *.tex setl filetype=tex
	autocmd BufWritePost *tex make
	autocmd FileType tex setl makeprg=pdflatex\ %
augroup END" }}}
"autocmd BufWritePre * :call <SID>StripTrailingWhitespace()
"autocmd BufWritePre * :silent call StripTrailingWhitespace()
autocmd FileType c,cpp,objc setl nolist noet sw=4 ts=4
autocmd FileType crontab setl nobackup nowritebackup
augroup graphviz " {{{
	autocmd!
	autocmd BufWritePost *.dot make
	autocmd FileType dot setl makeprg=make noet sw=4 ts=4

	autocmd BufWritePost *.msc make
	autocmd FileType msc setl makeprg=make noet sw=4 ts=4
augroup END" }}}
autocmd FileType java setlocal omnifunc=javacomplete#Complete completefunc=javacomplete#CompleteParamsInfo et sw=4 ts=4
autocmd FileType magit setl nobackup nowritebackup noswapfile
autocmd Filetype make setl noet
augroup perl " {{{
	autocmd!
	autocmd FileType perl,javascript,json,ruby inoremap <buffer>  {<CR>  {<CR>}<Esc>O
	autocmd FileType perl,javascript,json,ruby vnoremap <buffer>  {<CR> s{<CR>}<Esc>kp=iB
	autocmd FileType perl setl makeprg=perl\ -c\ % noet sw=4 ts=4
augroup END " }}}
autocmd FileType vo_base setl nolist
" Remove any trailing white space on save

augroup ruby " {{{
	autocmd!
	" Set makeprg accordingly to the ruby file being edited
	autocmd FileType ruby
				\ if expand('%') =~# '_test\.rb$' |
				\   compiler rubyunit | setl makeprg=bundle\ exec\ testrb\ \"%:p\" |
				\ elseif expand('%') =~# '\.feature' |
				\   compiler cucumber | setl makeprg=bundle\ exec\ cucumber\ \"%:p\" |
				\ elseif expand('%') =~# '_spec\.rb$' |
				\   compiler rspec | setl makeprg=bundle\ exec\ rspec\ \"%:p\" |
				\ else |
				\   compiler ruby | setl makeprg=ruby\ -wc\ \"%:p\" |
				\ endif

	autocmd BufWinEnter *.feature setl makeprg=bundle\ exec\ cucumber\ \"%:p\"
augroup END "}}}
augroup kubeconfig "{{{
	autocmd!
	autocmd BufRead ~/.kube/config setl ft=yaml nowrap
augroup END"}}}
augroup neomutt " {{{
	" Add format option 'w' to add trailing white space, indicating that paragraph
	" continues on next line. This is to be used with mutt's 'text_flowed' option.
	autocmd!
	autocmd BufNewFile,BufRead neomutt-*-\w\+,neomutt[[:alnum:]_-]\\\{6\} setfiletype mail
	autocmd FileType mail setlocal formatoptions+=w tw=72
augroup END " }}}
augroup dajoku "{{{
	autocmd!
	autocmd BufNewFile,BufRead .dajoku,.release-pipeline setfiletype yaml
augroup END
"}}}
augroup Global " {{{
	autocmd!
	"Create directory if it doesn't exist
	autocmd BufWritePre *
				\ if '<afile>' !~ '^scp:' && !isdirectory(expand('<afile>:h')) |
				\ call mkdir(expand('<afile>:h'), 'p') |
				\ endif

	"Format
	autocmd BufWritePost * call CocAction('format')

	autocmd BufReadPost *
				\ if expand("<afile>:p:h") !=? $TEMP |
				\   if line("'\"") > 0 && line("'\"") <= line("$") |
				\     exe "normal g`\"" |
				\     let b:doopenfold = 1 |
				\   endif |
				\ endif

	" Need to postpone using "zv" until after reading the modelines.
	autocmd BufWinEnter *
				\ if exists("b:doopenfold") |
				\   unlet b:doopenfold |
				\   exe "normal zv" |
				\ endif

" Set omnicomplete to a general thing if plugin doesn't implement it already
"  if has("autocmd") && exists("+omnifunc")
"  	autocmd Filetype *
"  				\	if &omnifunc == "" |
"  				\		setlocal omnifunc=syntaxcomplete#Complete |
"  				\	endif
"  endif
augroup END
" }}}
" }}}
" {{{ Mappings
" Quickly edit/source .vimrc
noremap <leader>ve :edit $HOME/.vimrc<CR>
noremap <leader>vs :source $HOME/.vimrc<CR>

" Yank(copy) to system clipboard
noremap <leader>y "+y

" Map <C-L> (redraw screen) to also turn off search highlighting until the
" next search
" nnoremap <C-L> :nohl<CR><C-L>
nnoremap <Leader>l :nohl<cr>:redraw!<cr>

"" Don't use arrow keys
"map <up> <nop>
"map <down> <nop>
"map <left> <nop>
"map <right> <nop>

" Search visually selected text
vmap * :<C-u>call <SID>VSetSearch()<CR>/<CR>
vmap # :<C-u>call <SID>VSetSearch()<CR>?<CR>

" Search
noremap ;; :%s:::g<Left><Left><Left>
noremap ;' :%s:::gc<Left><Left><Left><Left>

" Select previously pasted text
nnoremap <expr> gp '`[' . strpart(getregtype(), 0, 1) . '`]'

noremap! <C-A> <Home>
noremap! <C-E> <End>
cnoremap <C-K> <C-U>
"noremap! <C-F> <Right>
noremap! <C-B> <Left>

inoremap {<cr> {<cr>}<ESC>O

" Saving quicker
" Normal mode
nnoremap ;w :w<cr>
" Insert mode: Ctrl-S
inoremap <C-S> <Esc>:w<cr>a

" Remove trailing white space, dup empty lines, etc
nnoremap <Leader>w :call StripTrailingWhitespace()<cr>

" OMG! How did I not know about this earlier?
"noremap : q:I

" Find merge diffs
"nnoremap <Leader>fd /[<=>]\{3\}<cr>

" Toggle theme
nnoremap <F5> :call ToggleTheme()<cr>

"}}}
"{{{ Commands
command! Scratch call ScratchBuffer()
command! MakeScratch call MakeScratchBuffer()
"}}}
" {{{ Custom Functions
func! StripTrailingWhitespace()
	let l = line(".")
	let c = col(".")
	%s/\s\+$//e       " Remove trailing white space
	%s/\n\{3,}/\r\r/e " Condense multiple empty lines into one
	v/\_s*\S/d        " Only one \n at EOF    http://stackoverflow.com/posts/7501902/revisions
	call cursor(l, c)
endf

func! s:VSetSearch()
	let temp = @@
	norm! gvy
	let @/ = '\V' . substitute(escape(@@, '\'), '\n', '\\n', 'g')
	let @@ = temp
endf

func! ShowTab()
	let TabLevel = (indent('.') / &ts )
	if TabLevel == 0
		let TabLevel='*'
	endif
	return TabLevel
endf

func! ToggleTheme()
	if g:colors_name == "Tomorrow"
		:colo Tomorrow-Night
	elseif g:colors_name == "Tomorrow-Night"
		:colo Tomorrow
	endi
endf

func! ScratchBuffer()
	new
	call MakeScratchBuffer()
endf

func! MakeScratchBuffer()
	setl buftype=nofile
	setl bufhidden=hide
	setl noswapfile
endf

"func! GetCurrentPath()
"endf

" }}}
" {{{ Plugin configuration
" {{{ Airline
let g:airline_theme = "tomorrow"

let g:airline_mode_map = {
			\ '__' : '-',
			\ 'n'  : 'N',
			\ 'i'  : 'I',
			\ 'R'  : 'R',
			\ 'c'  : 'C',
			\ 'v'  : 'V',
			\ 'V'  : 'V',
			\ '' : 'V',
			\ 's'  : 'S',
			\ 'S'  : 'S',
			\ '' : 'S',
			\ 'h'  : 'H'
			\ }

let g:airline_powerline_fonts = 1
let g:airline_detect_spell = 0
"let g:airline#extensions#ale#enabled = 1
let g:airline#extensions#neomake#enabled = 1
let g:airline_extensions = []

"if !has('gui_running')
"unicode symbols
"let g:airline#extensions#branch#symbol = '⎇ '
"let g:airline#extensions#whitespace#symbol = 'Ξ'
"let g:airline_left_sep = '▶'
"let g:airline_right_sep = '◀'
"let g:airline_linecolumn_prefix = '␊ '
"let g:airline_paste_symbol = 'ρ'

"powerline symbols
"let g:airline_left_sep = ''
"let g:airline_left_alt_sep = ''
"let g:airline_right_sep = ''
"let g:airline_right_alt_sep = ''
"let g:airline#extensions#branch#symbol = ' '
"let g:airline#extensions#readonly#symbol = ''
"let g:airline_linecolumn_prefix = ' '
"endif
"let g:airline_section_a       (the mode/paste indicator)
"let g:airline_section_b       (the fugitive/lawrencium branch indicator)
"let g:airline_section_c       (bufferline or filename)
"let g:airline_section_gutter  (readonly, csv)
"let g:airline_section_x       (tagbar, filetype)
"let g:airline_section_y       (fileencoding, fileformat)
"let g:airline_section_z       (percentage, line number, column number)
"let g:airline_section_warning (syntastic, whitespace)
"let g:airline_section_z = ""

" }}}
" {{{ Block Toggle (blockle)
let g:blockle_mapping = '<Leader>L'
" }}}
" " {{{ Clang
" " Disable auto completion, always <c-x> <c-o> to complete
" " let g:clang_complete_auto = 0
" let g:clang_use_library = 1
" let g:clang_periodic_quickfix = 0
" let g:clang_close_preview = 1
"
" " For Objective-C, this needs to be active, otherwise multi-parameter methods won't be completed correctly
" let g:clang_snippets = 1
"
" " Snipmate does not work anymore, ultisnips is the recommended plugin
" let g:clang_snippets_engine = 'ultisnips'
"
" " This might change depending on your installation
" let g:clang_exec = '/usr/local/Cellar/llvm33/3.3/bin/clang-3.3'
" let g:clang_library_path = '/usr/local/Cellar/llvm33/3.3/lib/llvm-3.3/lib/libclang.dylib'
"
" " }}}
" {{{ Closetag
autocmd FileType html,eruby let b:closetag_html_style=1
autocmd FileType html,xhtml,xml,eruby,eelixir source ~/.vim/plugged/closetag.vim/plugin/closetag.vim
" }}}
" {{{ Command-T mappings
"nnoremap <silent> <Leader>t :CommandT<CR>
"nnoremap <silent> <Leader>b :CommandTBuffer<CR>
"nnoremap <silent> <Leader>j :CommandTJump<CR>
"nnoremap <silent> <Leader>T :CommandTTag<CR>
"nnoremap <silent> <Leader>f :CommandTFlush<CR>
" }}}
" {{{ CTRLP
"noremap <Leader>P :CtrlPLine<cr>
"let g:ctrlp_user_command = 'find %s -type f'        " MacOSX/Linux"
" Extensions
let g:ctrlp_extensions = ['tag', 'line', 'buffertag', 'changes', 'quickfix', 'undo']
let g:ctrlp_buftag_ctags_bin = '/usr/bin/ctags'

let g:ctrlp_match_window = "bottom,order:ttb,min:1,max:30"
let g:ctrlp_show_hidden = 1

let g:ctrlp_switch_buffer = 'e'
  "e - jump when <cr> is pressed, but only to windows in the current tab.
  "t - jump when <c-t> is pressed, but only to windows in another tab.
  "v - like "e", but jump when <c-v> is pressed.
  "h - like "e", but jump when <c-x> is pressed.
  "E, T, V, H - like "e", "t", "v", and "h", but jump to windows anywhere.
  "0 or <empty> - disable this feature.

"nnoremap <silent> <Leader>b :CtrlPBuffer<CR>
"nnoremap <silent> <Leader>j :CtrlPJump<CR>
"nnoremap <silent> <Leader>t :CtrlPTag<CR>
"nnoremap <silent> <Leader>f :CtrlPClearAllCaches<CR>
let g:ctrlp_max_depth = 40
let g:ctrlp_max_files = 0
let g:ctrlp_custom_ignore = 'node_modules\|DS_Store\|git\|npm\|vendor'

"let g:ctrlp_prompt_mappings = {
"\ 'PrtBS()':              ['<bs>', '<c-]>'],
"\ 'PrtDelete()':          ['<del>'],
"\ 'PrtDeleteWord()':      ['<c-w>'],
"\ 'PrtClear()':           ['<c-u>'],
"\ 'PrtSelectMove("j")':   ['<c-j>', '<down>'],
"\ 'PrtSelectMove("k")':   ['<c-k>', '<up>'],
"\ 'PrtSelectMove("t")':   ['<Home>', '<kHome>'],
"\ 'PrtSelectMove("b")':   ['<End>', '<kEnd>'],
"\ 'PrtSelectMove("u")':   ['<PageUp>', '<kPageUp>'],
"\ 'PrtSelectMove("d")':   ['<PageDown>', '<kPageDown>'],
"\ 'PrtHistory(-1)':       ['<c-n>'],
"\ 'PrtHistory(1)':        ['<c-p>'],
"\ 'AcceptSelection("e")': ['<cr>', '<2-LeftMouse>'],
"\ 'AcceptSelection("h")': ['<c-x>', '<c-cr>', '<c-s>'],
"\ 'AcceptSelection("t")': ['<c-t>'],
"\ 'AcceptSelection("v")': ['<c-v>', '<RightMouse>'],
"\ 'ToggleFocus()':        ['<s-tab>'],
"\ 'ToggleRegex()':        ['<c-r>'],
"\ 'ToggleByFname()':      ['<c-d>'],
"\ 'ToggleType(1)':        ['<c-f>', '<c-up>'],
"\ 'ToggleType(-1)':       ['<c-b>', '<c-down>'],
"\ 'PrtExpandDir()':       ['<tab>'],
"\ 'PrtInsert("c")':       ['<MiddleMouse>', '<insert>'],
"\ 'PrtInsert()':          ['<c-\>'],
"\ 'PrtCurStart()':        ['<c-a>'],
"\ 'PrtCurEnd()':          ['<c-e>'],
"\ 'PrtCurLeft()':         ['<c-h>', '<left>', '<c-^>'],
"\ 'PrtCurRight()':        ['<c-l>', '<right>'],
"\ 'PrtClearCache()':      ['<F5>'],
"\ 'PrtDeleteEnt()':       ['<F7>'],
"\ 'CreateNewFile()':      ['<c-y>'],
"\ 'MarkToOpen()':         ['<c-z>'],
"\ 'OpenMulti()':          ['<c-o>'],
"\ 'PrtExit()':            ['<esc>', '<c-c>', '<c-g>'],
"\ }
" }}}
" {{{ Fugitive
nnoremap <leader>ga  :Git add -p<CR>
nnoremap <leader>gb  :Gblame
nnoremap <leader>gc  :Gcommit -v
nnoremap <leader>gd  :Gdiff
nnoremap <leader>gl  :Glog<CR>
nnoremap <leader>gm  :Gmove<space>
nnoremap <leader>gpu :Git push<CR>
nnoremap <leader>gpr :Git pull --rebase<CR>
nnoremap <leader>gr  :Gremove<CR>
nnoremap <leader>gs  :Gstatus<CR>
" :Gshow shows what files a commit changes
command! -nargs=? -bar Gshow call setqflist(map(systemlist("git show --pretty='' --name-only <args>"), '{"filename": v:val, "lnum": 1}'))
" :Gdifffiles shows the files changes since SHA
command! -nargs=? -bar Gdifffiles call setqflist(map(systemlist("git diff --pretty='' --name-only <args>"), '{"filename": v:val, "lnum": 1}'))
" }}}
" {{{ GitGutter
let g:gitgutter_on_bufenter = 1
let g:gitgutter_all_on_focusgained = 0
let g:gitgutter_highlight_lines = 0
" }}}
" {{{ Gundo
nnoremap <F6> :GundoToggle<CR>
" }}}
" {{{  localvimrc
let g:localvimrc_sandbox = 0
let g:localvimrc_ask = 0
let g:localvimrc_blacklist = $HOME . "/Development/OSS/.*"
"let g:localvimrc_debug = 1
" }}}
" {{{ NERDTree
nnoremap <space><space> :NERDTreeToggle<cr>
nnoremap <space>f :NERDTreeFind<cr>
" Don't show temp files, swap files
let NERDTreeIgnore = ['\~$', '\..*\.sw\w$']
let g:NERDTreeDirArrowCollapsible = "-"
let g:NERDTreeDirArrowExpandable = ""
"let NERDTreeMinimalUI = 1
let g:NERDTreeQuitOnOpen = 1
let g:NERDTreeAutoDeleteBuffer = 1
" Open NERDtree when no file was specified
"autocmd vimenter * if !argc() | NERDTree | endif  " This also opens when -t TAG :/
let g:NERDTreeIndicatorMapCustom = {
    \ "Modified"  : "*",
    \ "Staged"    : "+",
    \ "Untracked" : "?",
    \ "Renamed"   : "~",
    \ "Unmerged"  : "═",
    \ "Deleted"   : "d",
    \ "Dirty"     : "Y",
    \ "Clean"     : "✔︎",
    \ 'Ignored'   : '☒',
    \ "Unknown"   : "?"
    \ }
" }}}
" {{{ Netrw
let g:netrw_http_cmd = "wget -q -O"
" }}}
" {{{ Perl stuff
let perl_include_pod = 1
let perl_extended_vars = 1
let perl_want_scope_in_variables = 1
"let perl_fold = 1
"let perl_fold_blocks = 1
" }}}
" {{{ Syntastic
:sign define SyntasticError text=> linehl=Error texthl=SpecialKey
let g:syntastic_aggregate_errors = 1 " Combine errors form different checkers
let g:syntastic_auto_jump = 0 " SO important
let g:syntastic_auto_loc_list = 1
let g:syntastic_enable_balloons = 1
let g:syntastic_enable_signs = 1
let g:syntastic_always_populate_loc_list = 1

let g:syntastic_error_symbol = 'x>'
let g:syntastic_warning_symbol = '!>'

let g:syntastic_disabled_filetypes = ['eruby']
let g:syntastic_eruby_checker = ''
let g:syntastic_rust_checker = ['rustc']

"let g:syntastic_objc_config_file = '.clang_complete'
"let g:syntastic_objc_checker = 'clang'

let g:syntastic_javascript_checkers = ['eslint']
let g:syntastic_javascript_eslint_exec = 'eslint_d'

let g:syntastic_ruby_rubocop_exec = 'rubocop'
let g:syntastic_ruby_checkers = ['rubocop', 'mri']

noremap [l :lprevious<CR>
noremap ]l :lnext<CR>
" }}}
" {{{ Tagbar
" Tagbar mappings
map <F2> :TagbarToggle<CR>
" let g:tagbar_ctags_bin = '/usr/local/bin/ctags'
let g:tagbar_autoclose = 0
let g:tagbar_autofocus = 1
"let g:tagbar_foldlevel = 3
"let g:tagbar_autoshowtag = 0

" let g:tagbar_iconchars = ['▶', '▼']  "(default on Linux and Mac OS X)
let g:tagbar_iconchars = ['▸', '▾']
" let g:tagbar_iconchars = ['▷', '◢']
" let g:tagbar_iconchars = ['+', '-']  "(default on Windows)

" autocmd VimEnter * nested :call tagbar#autoopen(1)
" autocmd FileType * nested :call tagbar#autoopen(0)
" autocmd BufEnter * nested :call tagbar#autoopen(0)
" "
" let g:tagbar_type_coffee = {
" 	\ 'ctagstype' : 'coffee',
" 	\ 'kinds'     : [
" 		\ 'c:classes',
" 		\ 'm:methods',
" 		\ 'f:functions',
" 		\ 'v:variables',
" 		\ 'f:fields',
" 	\ ]
" \ }
"
" let g:tagbar_type_markdown = {
" 	\ 'ctagstype' : 'markdown',
" 	\ 'kinds' : [
" 		\ 'h:Heading_L1',
" 		\ 'i:Heading_L2',
" 		\ 'k:Heading_L3'
" 	\ ]
" \ }
"
" }}}
" {{{ tmux-navigator
let g:tmux_navigator_no_mappings = 1

nnoremap <silent> <C-h> :TmuxNavigateLeft<cr>
nnoremap <silent> <C-j> :TmuxNavigateDown<cr>
nnoremap <silent> <C-k> :TmuxNavigateUp<cr>
nnoremap <silent> <C-l> :TmuxNavigateRight<cr>
nnoremap <silent> <C-\> :TmuxNavigatePrevious<cr>

" }}}
" {{{ tslime
vmap <C-c><C-c> <Plug>SendSelectionToTmux
nmap <C-c><C-c> <Plug>NormalModeSendToTmux
nmap <C-c>r <Plug>SetTmuxVars
" }}}
" {{{ turbux

func! TurbuxRunWithNeoTerm(command)
	:execute ":T" a:command
endf

let g:no_turbux_mappings = 1
"map <Enter> <Plug>SendTestToTmux
"map <Leader>t <Plug>SendTestToTmux
map <Leader>T <Plug>SendFocusedTestToTmux

let g:turbux_custom_runner = 'TurbuxRunWithNeoTerm'
"let g:turbux_runner  = 'dispatch'      " default: vimux OR tslime OR vim OR dispatch
"let g:turbux_runner  = 'vim'      " default: vimux OR tslime OR vim OR dispatch
let g:turbux_command_prefix = 'ze' " default: (empty)
"let g:turbux_command_rspec  = 'rspec'        " default: rspec
"let g:turbux_command_test_unit = 'ruby'     " default: ruby -Itest
"let g:turbux_command_cucumber = 'cucumber'  " default: cucumber
"let g:turbux_command_turnip = 'rspec'       " default: rspec -rturnip
" }}}
" {{{ Ultisnips config
let g:UltiSnipsExpandTrigger='<C-j>'
" }}}
" {{{ YouCompleteMe
let g:ycm_register_as_syntastic_checker = 0
" }}}
" {{{ vim-notes
let g:notes_directories = ['~/Documents/Notes']
let g:notes_suffix = '.txt'
let g:notes_smart_quotes = 0
" }}}
" {{{ Color settings
set t_Co=256
colo Tomorrow-Night
" }}}
" {{{ Highlight text that overflows
" highlight OverLength ctermbg=red ctermfg=white guibg=#d6d6d6
" match OverLength /\%81v.\+/
" }}}
" {{{ Pick.vim
nnoremap <Leader>e :call PickFile()<cr>
" }}}
" {{{ vim-test
let test#strategy = "neoterm"
"let test#strategy = "dispatch"
"let test#strategy = "tslime"
" }}}
" {{{ CtrlSF
nmap     <Leader>ff <Plug>CtrlSFPrompt
vmap     <Leader>ff <Plug>CtrlSFVwordPath
vmap     <Leader>fF <Plug>CtrlSFVwordExec
nmap     <Leader>fn <Plug>CtrlSFCwordPath
nmap     <Leader>fp <Plug>CtrlSFPwordPath
nnoremap <leader>fo :CtrlSFOpen<CR>
nnoremap <leader>ft :CtrlSFToggle<CR>
inoremap <leader>ft <Esc>:CtrlSFToggle<CR>
nmap     <leader>fl <Plug>CtrlSFQuickfixPrompt
vmap     <leader>fl <Plug>CtrlSFQuickfixVwordPath
vmap     <leader>fL <Plug>CtrlSFQuickfixVwordExec
" }}}
" {{{ Grepper
nnoremap <Leader>G :Grepper -tool git<cr>
nnoremap <Leader>g :Grepper -tool rg<cr>

nmap gs <Plug>(GrepperOperator)
xmap gs <Plug>(GrepperOperator)

let g:grepper = {}
let g:grepper.tools = ['git', 'rg']
let g:grepper.jump = 1
let g:grepper.next_tool = '<Leader>g'
" }}}
" DoToo {{{
autocmd BufRead,BufNewFile *.org setlocal ft=dotoo
let g:dotoo#capture#refile = '~/org/work.org'
let g:dotoo#capture#clock = 0
" }}}
" Gtd {{{
let g:gtd#dir = '~/Nextcloud/gtd/'
"let g:gtd#default_context = 'work'
let g:gtd#default_action = 'inbox'
let g:gtd#folding = 1
let g:gtd#map_refresh = 'r'
let g:gtd#review = [
			\ '!working',
			\ '!next',
			\ '(!inbox + !scheduled-'.strftime("%Y%m%d").')',
			\ '!todo',
			\ '!waiting',
			\ ]
nmap <Leader>Ge <Plug>GtdExplore
nmap <Leader>Gn <Plug>GtdNew
vmap <Leader>Gn <Plug>GtdNew
nmap <Leader>Gd <Plug>GtdDisplay
"nmap <Leader>Gr :Gtd (!inbox + !scheduled-<C-R>=strftime("%Y%m%d")<CR>)<CR>
nmap <Leader>Gr :GtdReview<CR>
nmap <Leader>Gt :Gtd !todo<CR>
nmap <Leader>Gw :Gtd !waiting<CR>
nmap <Leader>GD :Gtd !done<CR>
nmap <Leader>Gs :Gtd !scheduled<CR>
nmap <Leader>Gf :GtdFiles<CR>
" }}}
" {{{ vimagit
let g:magit_default_fold_level=2
let g:magit_discard_untracked_do_delete=1
" }}}
" {{{ vim-go
let g:go_fmt_command = "goimports"
let g:go_fmt_fail_silently = 1
let g:go_rename_command = 'gopls'
"autocmd FileType go let omnifunc=go#complete#Complete

noremap ,tg :T go test .<Enter>

augroup templates " {{{
	autocmd!
	autocmd BufRead,BufNewFile *.tmpl setlocal ft=gotexttmpl
augroup END " }}}
" }}}
" {{{ Colorizer
let g:colorizer_auto_filetype = 'html,css,i3,config'
" }}}
" {{{ vim-jsx
let g:jsx_ext_required = 0
let g:jsx_pragma_required = 0
let g:xml_syntax_folding = 0
" }}}
" Neomake {{{
" When writing a buffer (no delay), and on normal mode changes (after 750ms).
"  call neomake#configure#automake('nrwi', 750, 500)
"  let g:neomake_ruby_enabled_makers = ['rubocop', 'mri']
" Default: let g:neomake_ruby_enabled_makers = ['flog', 'reek', 'rubocop', 'mri', 'rubylint']
" }}}
" ALE {{{
"  let g:ale_completion_enabled = 0
"  let g:ale_fix_on_save = 1
"  let g:ale_lint_on_enter = 1
"  let g:ale_lint_on_save = 1
"  let g:ale_linters = {
"  			\   'ruby': ['solargraph', 'rubocop', 'sorbet'],
"  			\   'javascript.jsx': ['eslint'],
"  			\   'go': ['bingo', 'golangci-lint', 'staticcheck', 'govet', 'golint'],
"  			\   'diff': [],
"  			\ }
"  let g:ale_fixers = {
"  			\   'eruby.yaml': [
"  			\     'remove_trailing_lines',
"  			\     'trim_whitespace',
"  			\     'prettier',
"  			\   ],
"  			\   'go': [
"  			\     'goimports',
"  			\     'remove_trailing_lines',
"  			\     'trim_whitespace',
"  			\   ],
"  			\   'javascript': [
"  			\     'remove_trailing_lines',
"  			\     'trim_whitespace',
"  			\     'eslint',
"  			\     'prettier',
"  			\     'standard',
"  			\   ],
"  			\   'javascript.tsx': [
"  			\     'remove_trailing_lines',
"  			\     'trim_whitespace',
"  			\     'eslint',
"  			\     'prettier',
"  			\     'standard',
"  			\   ],
"  			\   'typescript': [
"  			\     'remove_trailing_lines',
"  			\     'trim_whitespace',
"  			\     'eslint',
"  			\     'prettier',
"  			\     'standard',
"  			\   ],
"  			\   'typescriptreact': [
"  			\     'remove_trailing_lines',
"  			\     'trim_whitespace',
"  			\     'eslint',
"  			\     'prettier',
"  			\     'standard',
"  			\   ],
"  			\   'make': [
"  			\     'remove_trailing_lines',
"  			\     'trim_whitespace',
"  			\   ],
"  			\   'ruby': [
"  			\     'rubocop',
"  			\   ],
"  			\   'yaml': [
"  			\     'remove_trailing_lines',
"  			\     'trim_whitespace',
"  			\     'prettier',
"  			\   ],
"  			\   'diff': [],
"  			\   'sh': [
"  			\     'remove_trailing_lines',
"  			\     'trim_whitespace',
"  			\     'shfmt',
"  			\   ],
"  			\   'python': [
"  			\     'add_blank_lines_for_python_control_statements',
"  			\     'add_blank_lines_for_python_control_statements',
"  			\     'autopep8',
"  			\     'isort',
"  			\     'remove_trailing_lines',
"  			\     'reorder-python-imports',
"  			\     'trim_whitespace',
"  			\   ],
"  			\   'terraform': [
"  			\      'remove_trailing_lines',
"  			\      'terraform',
"  			\      'trim_whitespace',
"  			\   ],
"  			\   'json': [
"  			\     'prettier'
"  			\   ],
"  			\ }
"  
"  set completeopt=menu,menuone,preview,noselect,noinsert
"  let g:ale_ruby_solargraph_executable = 'bundle'
"  "let g:ale_ruby_rubocop_executable = 'bundle'
"  let g:ale_go_bingo_executable = 'gopls'
"  let g:ale_sh_shfmt_options = "-i 2 -ci -bn"
"  let g:ale_completion_tsserver_autoimport = 1
"  let g:ale_go_golangci_lint_options = ''
"  
"  augroup ale
"  	autocmd!
"  	autocmd BufEnter diff let ale_fix_on_save=0
"  	autocmd BufEnter python let ale_fix_on_save=0
"  augroup END
"  
"  augroup typescript
"  	autocmd!
"  	autocmd BufNewFile,BufRead *.tsx,*.ts  noremap <C-]> :ALEGoToDefinition<cr>
"  	autocmd BufNewFile,BufRead *.tsx,*.ts  noremap <C-w><C-]> :ALEGoToDefinitionInSplit<cr>
"  	autocmd BufNewFile,BufRead *.tsx,*.ts  noremap <C-w>] :ALEGoToDefinitionInSplit<cr>
"  augroup END
"  
"  set omnifunc=ale#completion#OmniFunc
" }}}
" deoplete{{{
" Enable deoplete when InsertEnter.
"  let g:deoplete#enable_at_startup = 0
"  augroup deoplete
"  	autocmd!
"  	autocmd InsertEnter * call deoplete#enable()
"  augroup END
"  
"  " call deoplete#custom#source('ale', 'rank', 999)
"  call deoplete#custom#option({
"  			\ 'auto_complete_delay': 200,
"  			\ 'smart_case': v:true,
"  			\ })
"  " call deoplete#custom#option('sources', {'_': ['ale','buffer','around']})
"  
"  inoremap <expr><TAB> pumvisible() ? "\<C-n>" : "\<TAB>"
"  inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<S-TAB>"
" }}}
" {{{ Netrw
nnoremap \| :execute 'Lexplore' expand('%:h')<cr>
let g:netrw_winsize=25
let g:netrw_liststyle=3
" }}}
" FZF {{{
"   " Global line completion (not just open buffers. ripgrep required.)
"   inoremap <expr> <c-x><c-l> fzf#vim#complete(fzf#wrap({
"     \ 'prefix': '^.*$',
"     \ 'source': 'rg -n ^ --color always',
"     \ 'options': '--ansi --delimiter : --nth 3..',
"     \ 'reducer': { lines -> join(split(lines[0], ':\zs')[2:], '') }}))
"nmap <Leader>p :Files<cr>
" Default fzf layout
" - down / up / left / right
"let g:fzf_layout = { 'down': '~40%' }
nnoremap <silent> <Leader>bb :FzfPreviewBuffers<CR>
nnoremap <silent> <Leader><c-p> :FzfPreviewGitStatus<cr>
nnoremap <silent> <Leader>mr :FzfPreviewMruFiles<CR>
nnoremap <silent> <Leader>L :FzfPreviewLines<cr>
nnoremap <silent> <Leader>p :FzfPreviewProjectFiles<cr>
nnoremap <silent> <Leader>t :FzfPreviewCtags<CR>
"nnoremap <silent> <Leader>g :FzfPreviewProjectGrep 
" }}}
" fzf-quickfix {{{
nmap <Leader>q <Plug>(fzf-quickfix)
" }}}
" echodoc {{{
let g:echodoc_enable_at_startup = 1
"let g:echodoc#type = 'virtual'
let g:echodoc#type = 'floating'
" }}}
" Gutentags {{{
let g:gutentags_exclude_project_root = ['/usr/local', '.tox']
" }}}
" Pencil {{{
augroup pencil
  autocmd!
  autocmd FileType markdown,mkd call pencil#init()
  autocmd FileType text call pencil#init()
  "autocmd FileType mail call pencil#init()
augroup END
" }}}
" Lexical {{{
let g:lexical#thesaurus = ['~/.vim/thesaurus/mthesaur.txt',]

augroup lexical
  autocmd!
  autocmd FileType markdown,mkd call lexical#init()
  autocmd FileType textile call lexical#init()
  autocmd FileType text call lexical#init({ 'spell': 0 })
  "autocmd FileType mail call lexical#init()
augroup END
" }}}
" neosnippet{{{
imap <C-j>     <Plug>(neosnippet_expand_or_jump)
smap <C-j>     <Plug>(neosnippet_expand_or_jump)
xmap <C-j>     <Plug>(neosnippet_expand_target)

let g:neosnippet#snippets_directory='~/.vim/my-snippets,~/.vim/plugged/neosnippet-snippets/neosnippets'
" }}}
" fzf-preview {{{
let g:fzf_preview_command = 'bat --color=always --style=grid {-1}'
let g:fzf_preview_lines_command = 'bat --color=always --style=grid --plain'
" }}}
" coc.vim {{{
set shortmess+=c
set signcolumn=yes
" Use tab for trigger completion with characters ahead and navigate.
" NOTE: Use command ':verbose imap <tab>' to make sure tab is not mapped by
" other plugin before putting this into your config.
inoremap <silent><expr> <TAB>
      \ pumvisible() ? "\<C-n>" :
      \ <SID>check_back_space() ? "\<TAB>" :
      \ coc#refresh()
inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<C-h>"

function! s:check_back_space() abort
  let col = col('.') - 1
  return !col || getline('.')[col - 1]  =~# '\s'
endfunction

" Use <c-space> to trigger completion.
inoremap <silent><expr> <c-space> coc#refresh()

" Use <cr> to confirm completion, `<C-g>u` means break undo chain at current
" position. Coc only does snippet and additional edit on confirm.
if exists('*complete_info')
  inoremap <expr> <cr> complete_info()["selected"] != "-1" ? "\<C-y>" : "\<C-g>u\<CR>"
else
  imap <expr> <cr> pumvisible() ? "\<C-y>" : "\<C-g>u\<CR>"
endif

" Use `[g` and `]g` to navigate diagnostics
nmap <silent> [g <Plug>(coc-diagnostic-prev)
nmap <silent> ]g <Plug>(coc-diagnostic-next)

" GoTo code navigation.
nmap <silent> gd <Plug>(coc-definition)
nmap <silent> gy <Plug>(coc-type-definition)
nmap <silent> gi <Plug>(coc-implementation)
nmap <silent> gr <Plug>(coc-references)

" Use K to show documentation in preview window.
nnoremap <silent> K :call <SID>show_documentation()<CR>

function! s:show_documentation()
  if (index(['vim','help'], &filetype) >= 0)
    execute 'h '.expand('<cword>')
  else
    call CocAction('doHover')
  endif
endfunction

" Highlight the symbol and its references when holding the cursor.
autocmd CursorHold * silent call CocActionAsync('highlight')

" Symbol renaming.
nmap <leader>rn <Plug>(coc-rename)

" Formatting selected code.
xmap <leader>sf  <Plug>(coc-format-selected)
nmap <leader>sf  <Plug>(coc-format-selected)

augroup cocvim
  autocmd!
  " Setup formatexpr specified filetype(s).
  autocmd FileType typescript,json setl formatexpr=CocAction('formatSelected')
  " Update signature help on jump placeholder.
  autocmd User CocJumpPlaceholder call CocActionAsync('showSignatureHelp')
  set tagfunc=CocTagFunc
augroup end

" Applying codeAction to the selected region.
" Example: `<leader>aap` for current paragraph
xmap <leader>a  <Plug>(coc-codeaction-selected)
nmap <leader>a  <Plug>(coc-codeaction-selected)

" Remap keys for applying codeAction to the current line.
nmap <leader>ac  <Plug>(coc-codeaction)
" Apply AutoFix to problem on the current line.
nmap <leader>qf  <Plug>(coc-fix-current)

" Introduce function text object
" NOTE: Requires 'textDocument.documentSymbol' support from the language server.
xmap if <Plug>(coc-funcobj-i)
xmap af <Plug>(coc-funcobj-a)
omap if <Plug>(coc-funcobj-i)
omap af <Plug>(coc-funcobj-a)

" Use <TAB> for selections ranges.
" NOTE: Requires 'textDocument/selectionRange' support from the language server.
" coc-tsserver, coc-python are the examples of servers that support it.
nmap <silent> <TAB> <Plug>(coc-range-select)
xmap <silent> <TAB> <Plug>(coc-range-select)

" Add `:Format` command to format current buffer.
command! -nargs=0 Format :call CocAction('format')

" Add `:Fold` command to fold current buffer.
command! -nargs=? Fold :call CocAction('fold', <f-args>)

" Add `:OR` command for organize imports of the current buffer.
command! -nargs=0 OR   :call CocAction('runCommand', 'editor.action.organizeImport')

" Add (Neo)Vim's native statusline support.
" NOTE: Please see `:h coc-status` for integrations with external plugins that
" provide custom statusline: lightline.vim, vim-airline.
set statusline^=%{coc#status()}%{get(b:,'coc_current_function','')}

" Mappings using CoCList:
" Show all diagnostics.
nnoremap <silent> <leader>cd  :<C-u>CocList diagnostics<cr>
" Manage extensions.
nnoremap <silent> <leader>ce  :<C-u>CocList extensions<cr>
" Show commands.
nnoremap <silent> <leader>cc  :<C-u>CocList commands<cr>
" Find symbol of current document.
nnoremap <silent> <leader>co  :<C-u>CocList outline<cr>
" Search workspace symbols.
nnoremap <silent> <leader>cs  :<C-u>CocList -I symbols<cr>
" Do default action for next item.
nnoremap <silent> <leader>cj  :<C-u>CocNext<CR>
" Do default action for previous item.
nnoremap <silent> <leader>ck  :<C-u>CocPrev<CR>
" Resume latest coc list.
nnoremap <silent> <leader>cp  :<C-u>CocListResume<CR>
" }}}
" solargraph {{{
" }}}
" }}}
source ~/.vim/include/abbr.vim

let g:go_version_warning=0

" vim:tw=0:ts=4:sw=4:noet:nolist:foldmethod=marker
