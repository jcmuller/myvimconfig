#extends ruby

snippet defd "def_delegator"
def_delegator :${1:@del_obj}, :${2:del_meth}, :${3:new_name}
endsnippet

snippet defds "def_delegators"
def_delegators :${1:@del_obj}, :${2:del_methods}
endsnippet

snippet eab "eab"
each_byte { |${1:byte}| ${2} }
endsnippet

snippet eac- "each_char { |chr| .. }"
each_char { |${1:chr}| ${2} }
endsnippet

snippet eac- "each_cons(..) { |group| .. }"
each_cons(${1:2}) { |${2:group}| ${3} }
endsnippet

snippet eai "eai"
each_index { |${1:i}| ${2} }
endsnippet

snippet eak "eak"
each_key { |${1:key}| ${2} }
endsnippet

snippet eal "eal"
each_line { |${1:line}| ${2} }
endsnippet

snippet eap "eap"
each_pair { |${1:name}, ${2:val}| ${3} }
endsnippet

snippet eas- "eas-"
each_slice(${1:2}) { |${2:group}| ${3} }
endsnippet

snippet eav "eav"
each_value { |${1:val}| ${2} }
endsnippet

snippet eawi "eawi"
each_with_index { |${1:e}, ${2:i}| ${3} }
endsnippet

snippet reve "reve"
reverse_each { |${1:e}| ${2} }
endsnippet

snippet mapwi- "mapwi-"
enum_with_index.map { |${1:e}, ${2:i}| ${3} }
endsnippet

snippet sorb "sorb"
sort_by { |${1:e}| ${2} }
endsnippet

snippet ran "ran"
sort_by { rand }
endsnippet

snippet all "all"
all? { |${1:e}| ${2} }
endsnippet

snippet any "any"
any? { |${1:e}| ${2} }
endsnippet

snippet classify "classify"
classify { |${1:e}| ${2} }
endsnippet

snippet col "col"
collect { |${1:e}| ${2} }
endsnippet

snippet det "det"
detect { |${1:e}| ${2} }
endsnippet

snippet fet "fet"
fetch(${1:name}) { |${2:key}| ${3} }
endsnippet

snippet fin "fin"
find { |${1:e}| ${2} }
endsnippet

snippet fina "fina"
find_all { |${1:e}| ${2} }
endsnippet

snippet gre "gre"
grep(${1:/pattern/}) { |${2:match}| ${3} }
endsnippet

snippet sub "sub"
${1:g}sub(${2:/pattern/}) { |${3:match}| ${4} }
endsnippet

snippet sca "sca"
scan(${1:/pattern/}) { |${2:match}| ${3} }
endsnippet

snippet max "max"
max { |a, b|, ${1} }
endsnippet

snippet min "min"
min { |a, b|, ${1} }
endsnippet

snippet par "par"
partition { |${1:e}|, ${2} }
endsnippet

snippet rej "rej"
reject { |${1:e}|, ${2} }
endsnippet

snippet sel "sel"
select { |${1:e}|, ${2} }
endsnippet

snippet lam "lam"
lambda { |${1:args}| ${2} }
endsnippet

snippet -> "lambda"
lambda { ${1} }${0}
endsnippet


snippet do "do"
do |${1:variable}|
	$0
end
endsnippet

snippet : ":"
:${1:key} => ${2:"value"}$0
endsnippet

snippet ope "ope"
open(${1:"path/or/url/or/pipe"}, "${2:w}") { |${3:io}| ${4} }
endsnippet

snippet patfh "patfh"
File.join(File.dirname(__FILE__), *%2[${1:rel path here}])$0
endsnippet

snippet unif "unif"
ARGF.each_line${1} do |${2:line}|
	$0
end
endsnippet

snippet optp "optp"
require "optparse"

options = {
	${1:default => "args"}
}

  opts = OptionParser.new do |opts|
	opts.banner = "Usage: #{File.basename($PROGRAM_NAME)}"

	$2

	opts.separator ""
  	opts.on_tail( "-h", "--help", "Show this message" ) do
		puts opts
		exit
	end
end

opts.parse!
endsnippet

snippet opt "opt"
opts.on( "-${1:o}", "--${2:long-option-name}", ${3:String}, "${4:Option description.}") do |${5:opt}|
	$0
end
endsnippet

snippet tc "tc"
require "test/unit"

require "${1:library_file_name}"

class Test${2:$1} < Test::Unit::TestCase
	def test_${3:case_name}
		$0
	end
end
endsnippet

snippet ts "ts"
require "test/unit"

require "tc_${1:test_case_file}"
require "tc_${2:test_case_file}"$0
endsnippet

snippet as "as"
assert(${1:test}, "${2:Failure message.}")$0
endsnippet

snippet ase "ase"
assert_equal(${1:expected}, ${2:actual})$0
endsnippet

snippet asne "asne"
assert_not_equal(${1:unexpected}, ${2:actual})$0
endsnippet

snippet asid "asid"
assert_in_delta(${1:expected_float}, ${2:actual_float}, ${3:2 ** -20})$0
endsnippet

snippet asio "asio"
assert_instance_of(${1:ExpectedClass}, ${2:actual_instance})$0
endsnippet

snippet asko "asko"
assert_kind_of(${1:ExpectedKind}, ${2:actual_instance})$0
endsnippet

snippet asn "asn"
assert_nil(${1:instance})$0
endsnippet

snippet asnn "asnn"
assert_not_nil(${1:instance})$0
endsnippet

snippet asm "asm"
assert_match(/${1:expected_pattern}/, ${2:actual_string})$0
endsnippet

snippet asnm "asnm"
assert_no_match(/${1:unexpected_pattern}/, ${2:actual_string})$0
endsnippet

snippet aso "aso"
assert_operator(${1:left}, :${2:operator}, ${3:right})$0
endsnippet

snippet asr "asr"
assert_raise(${1:Exception}) { ${2} }
endsnippet

snippet asnr "asnr"
assert_nothing_raised(${1:Exception}) { ${2} }
endsnippet

snippet asrt "asrt"
assert_respond_to(${1:object}, :${2:method})$0
endsnippet

snippet ass "assert_same(..)"
assert_same(${1:expected}, ${2:actual})$0
endsnippet

snippet ass "assert_send(..)"
assert_send([${1:object}, :${2:message}, ${3:args}])$0
endsnippet

snippet asns "asns"
assert_not_same(${1:unexpected}, ${2:actual})$0
endsnippet

snippet ast "ast"
assert_throws(:${1:expected}) { ${2} }
endsnippet

snippet asnt "asnt"
assert_nothing_thrown { ${1} }
endsnippet

snippet fl "fl"
flunk("${1:Failure message.}")$0
endsnippet

snippet bm- "bm-"
TESTS = ${1:10_000}
Benchmark.bmbm do |results|
	$0
end
endsnippet

snippet rep "rep"
results.report("${1:name}:") { TESTS.times { ${2} }}
endsnippet

snippet Md "Md"
File.open(${1:"path/to/file.dump"}, "wb") { |${2:file}| Marshal.dump(${3:obj}, $2) }$0
endsnippet

snippet Ml "Ml"
File.open(${1:"path/to/file.dump"}, "rb") { |${2:file}| Marshal.load($2) }$0
endsnippet

snippet deec "deec"
Marshal.load(Marshal.dump(${1:obj_to_copy}))$0
endsnippet

snippet Pn- "Pn-"
PStore.new(${1:"file_name.pstore"})$0
endsnippet

snippet tra "tra"
transaction(${1:true}) { ${2} }
endsnippet

snippet xml- "xml-"
REXML::Document.new(File.read(${1:"path/to/file"}))$0
endsnippet

snippet xpa "xpa"
elements.each(${1:"//Xpath"}) do |${2:node}|
	$0
end
endsnippet

snippet clafn "clafn"
split("::").inject(Object) { |par, const| par.const_get(const) }
endsnippet

snippet sinc "sinc"
class << self; self end
endsnippet

snippet nam "nam"
namespace :${1:`Filename()`} do
	$0
end
endsnippet

snippet tas "tas"
desc "${1:Task description\}"
task :${2:task_name => [:dependent, :tasks]} do
	$0
end
endsnippet

snippet $:. "$:."
$:.unshift
endsnippet

snippet { "{"
{ |${1}| }
endsnippet

snippet fex "fex"
File.expand_path(
endsnippet

snippet fx "File.expand_path"
File.expand_path(
endsnippet

snippet ./ "relative path"
File.expand_path('../${1}', __FILE__)${0}
endsnippet

snippet ../ "relative path"
File.expand_path('../../${1}', __FILE__)${0}
endsnippet

snippet fj "fj"
File.join(
endsnippet

snippet . "."
File.dirname(__FILE__)
endsnippet

snippet rt "respond to (Rails)"
respond_to do |format|
  format.html${1}
end${0}
endsnippet

snippet desc "describe class"
describe ${1} do
  $2
end
endsnippet

snippet it "rspec example"
it "$1" do
  $2
end
$3
endsnippet

snippet cont "rspec context"
context "$1" do
  $2
end
$3
endsnippet

snippet feat "steak feature"
feature "$1" do
  $2
end
$3
endsnippet

snippet scen "steak scenario"
scenario "$1" do
  $2
end
$3
endsnippet
